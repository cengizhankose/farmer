import {
  Opportunity,
  HistoricalData,
  ChartData,
  Timeframe
} from '@shared/core';
import { StacksApiService } from './stacks-api';
import { HistoricalDataService } from './historical-data';
import { EnhancedDataService } from './enhanced-data-service';

export interface ChartDataProviderConfig {
  cacheTimeout?: number;
  maxDataPoints?: number;
  enableRealtimeUpdates?: boolean;
}

export interface MultiTimeframeChartData {
  '7D': ChartData;
  '30D': ChartData;
  '90D': ChartData;
}

export interface EnhancedChartData extends ChartData {
  timestamps: string[];
  tvlUsd: number[];
  apy: number[];
  volumeUsd: number[];
  participants: number[];
  priceData: {
    [token: string]: number[];
  };
  feesUsd: number[];
  riskScore: number[];
}

export class ChartDataProvider {
  private stacksApi: StacksApiService;
  private historicalDataService: HistoricalDataService;
  private enhancedDataService: EnhancedDataService;
  private cache = new Map<string, { data: any; expiry: number }>();
  private config: Required<ChartDataProviderConfig>;

  constructor(config: ChartDataProviderConfig = {}) {
    this.stacksApi = new StacksApiService();
    this.historicalDataService = new HistoricalDataService();
    this.enhancedDataService = new EnhancedDataService();

    this.config = {
      cacheTimeout: config.cacheTimeout || 5 * 60 * 1000, // 5 minutes
      maxDataPoints: config.maxDataPoints || 90,
      enableRealtimeUpdates: config.enableRealtimeUpdates || false,
    };
  }

  async getPoolChartData(
    opportunity: Opportunity,
    timeframes: Timeframe[] = ['7D', '30D', '90D']
  ): Promise<{ [timeframe: string]: EnhancedChartData }> {
    const cacheKey = `chart-${opportunity.id}-${timeframes.join('-')}`;
    const cached = this.cache.get(cacheKey);

    if (cached && cached.expiry > Date.now()) {
      return cached.data;
    }

    try {
      const results: { [timeframe: string]: EnhancedChartData } = {};

      // Process all timeframes in parallel
      const timeframePromises = timeframes.map(async (timeframe) => {
        results[timeframe] = await this.getTimeframeData(opportunity, timeframe);
      });

      await Promise.all(timeframePromises);

      // Cache result
      this.cache.set(cacheKey, {
        data: results,
        expiry: Date.now() + this.config.cacheTimeout,
      });

      return results;
    } catch (error) {
      console.warn(`Failed to fetch chart data for ${opportunity.id}:`, error);
      return this.createFallbackChartData(timeframes);
    }
  }

  private async getTimeframeData(
    opportunity: Opportunity,
    timeframe: Timeframe
  ): Promise<EnhancedChartData> {
    const days = this.timeframeToDays(timeframe);

    // Fetch data from multiple sources in parallel
    const [
      defiLlamaData,
      enhancedData,
      transactionData,
      riskData
    ] = await Promise.all([
      this.historicalDataService.getHistoricalData(opportunity, days),
      this.enhancedDataService.getEnhancedStabilityData(opportunity),
      this.getTransactionData(opportunity, days),
      this.getRiskData(opportunity, days)
    ]);

    return this.mergeDataSources(
      defiLlamaData,
      enhancedData,
      transactionData,
      riskData,
      timeframe
    );
  }

  private async getTransactionData(
    opportunity: Opportunity,
    days: number
  ): Promise<{
    volumeData: number[];
    participantData: number[];
    feeData: number[];
  }> {
    try {
      // Try to get real transaction data from Stacks API
      if (opportunity.poolId || opportunity.contract) {
        const contractId = opportunity.contract || opportunity.poolId;
        const metrics = await this.stacksApi.calculateParticipantMetrics(contractId, days);

        // Generate daily volume and participant data
        const volumeData = this.generateDailySeries(metrics.totalVolume / days, days, 0.3);
        const participantData = this.generateDailySeries(metrics.uniqueParticipants, days, 0.2);
        const feeData = this.generateDailySeries(metrics.totalVolume * 0.003 / days, days, 0.4); // 0.3% avg fee

        return { volumeData, participantData, feeData };
      }
    } catch (error) {
      console.warn('Failed to get transaction data, using estimates:', error);
    }

    // Fallback to estimation
    return this.estimateTransactionData(opportunity, days);
  }

  private async getRiskData(
    opportunity: Opportunity,
    days: number
  ): Promise<number[]> {
    try {
      // Calculate daily risk scores based on volatility and other factors
      const baseRisk = opportunity.risk || 50;
      const riskVolatility = 0.1; // 10% daily volatility in risk assessment

      return this.generateDailySeries(baseRisk, days, riskVolatility, {
        min: 0,
        max: 100,
        meanReversion: 0.05
      });
    } catch (error) {
      console.warn('Failed to calculate risk data:', error);
      return Array(days).fill(opportunity.risk || 50);
    }
  }

  private mergeDataSources(
    defiLlamaData: HistoricalData,
    enhancedData: any,
    transactionData: { volumeData: number[]; participantData: number[]; feeData: number[] },
    riskData: number[],
    timeframe: Timeframe
  ): EnhancedChartData {
    const days = this.timeframeToDays(timeframe);
    const timestamps = this.generateTimestamps(days);

    // Get the appropriate historical data arrays
    const tvlKey = `tvl_${days}` as keyof HistoricalData;
    const aprKey = `apr_${days}` as keyof HistoricalData;

    let tvlData = defiLlamaData[tvlKey] as number[] || this.generateSyntheticTvlData(opportunity.tvlUsd, days);
    let aprData = defiLlamaData[aprKey] as number[] || this.generateSyntheticAprData(opportunity.apr, days);

    // Ensure data arrays are the correct length
    tvlData = this.normalizeArrayLength(tvlData, days);
    aprData = this.normalizeArrayLength(aprData, days);

    // Calculate APY from APR
    const apyData = aprData.map(apr => this.aprToApy(apr));

    // Generate price data for each token
    const priceData: { [token: string]: number[] } = {};
    opportunity.tokens.forEach(token => {
      priceData[token] = this.generateSyntheticPriceData(1.0, days, 0.05); // Start at $1.0
    });

    return {
      timestamps,
      tvlUsd: tvlData,
      apy: apyData,
      volumeUsd: transactionData.volumeData,
      participants: transactionData.participantData,
      priceData,
      feesUsd: transactionData.feeData,
      riskScore: riskData,
    };
  }

  private generateTimestamps(days: number): string[] {
    const timestamps: string[] = [];
    const now = new Date();

    for (let i = days - 1; i >= 0; i--) {
      const date = new Date(now.getTime() - i * 24 * 60 * 60 * 1000);
      timestamps.push(date.toISOString());
    }

    return timestamps;
  }

  private generateDailySeries(
    baseValue: number,
    days: number,
    volatility: number,
    options: { min?: number; max?: number; meanReversion?: number } = {}
  ): number[] {
    const series: number[] = [];
    let currentValue = baseValue;
    const meanReversion = options.meanReversion || 0;

    for (let i = 0; i < days; i++) {
      // Random walk with optional mean reversion
      const randomChange = (Math.random() - 0.5) * 2 * volatility;
      const reversion = meanReversion * (baseValue - currentValue) / baseValue;

      currentValue *= (1 + randomChange + reversion);

      // Apply bounds if specified
      if (options.min !== undefined) currentValue = Math.max(options.min, currentValue);
      if (options.max !== undefined) currentValue = Math.min(options.max, currentValue);

      series.push(currentValue);
    }

    return series;
  }

  private generateSyntheticTvlData(baseTvl: number, days: number): number[] {
    const volatility = Math.min(0.1, 1000000 / baseTvl); // Smaller pools more volatile
    return this.generateDailySeries(baseTvl, days, volatility, {
      min: baseTvl * 0.3,
      max: baseTvl * 3,
      meanReversion: 0.02
    });
  }

  private generateSyntheticAprData(baseApr: number, days: number): number[] {
    const volatility = Math.min(0.15, baseApr * 0.3);
    return this.generateDailySeries(baseApr, days, volatility, {
      min: 0.001,
      max: Math.max(2.0, baseApr * 2),
      meanReversion: 0.03
    });
  }

  private generateSyntheticPriceData(basePrice: number, days: number, volatility: number): number[] {
    return this.generateDailySeries(basePrice, days, volatility, {
      min: basePrice * 0.5,
      max: basePrice * 2,
      meanReversion: 0.01
    });
  }

  private estimateTransactionData(
    opportunity: Opportunity,
    days: number
  ): { volumeData: number[]; participantData: number[]; feeData: number[] } {
    // Estimate based on TVL and APR
    const estimatedDailyVolume = opportunity.tvlUsd * 0.1; // 10% daily turnover assumption
    const estimatedParticipants = Math.sqrt(opportunity.tvlUsd / 5000) * 0.5; // Conservative estimate
    const estimatedDailyFees = estimatedDailyVolume * 0.003; // 0.3% avg fee

    return {
      volumeData: this.generateDailySeries(estimatedDailyVolume, days, 0.4),
      participantData: this.generateDailySeries(estimatedParticipants, days, 0.2, { min: 1 }),
      feeData: this.generateDailySeries(estimatedDailyFees, days, 0.5),
    };
  }

  private normalizeArrayLength(array: number[], targetLength: number): number[] {
    if (array.length === targetLength) return array;
    if (array.length > targetLength) return array.slice(-targetLength);

    // Pad with last value if too short
    const lastValue = array[array.length - 1] || 0;
    return [...array, ...Array(targetLength - array.length).fill(lastValue)];
  }

  private timeframeToDays(timeframe: Timeframe): number {
    switch (timeframe) {
      case '7D': return 7;
      case '30D': return 30;
      case '90D': return 90;
      default: return 30;
    }
  }

  private aprToApy(apr: number): number {
    // Convert APR to APY with daily compounding
    return Math.pow(1 + apr / 365, 365) - 1;
  }

  private createFallbackChartData(timeframes: Timeframe[]): { [timeframe: string]: EnhancedChartData } {
    const results: { [timeframe: string]: EnhancedChartData } = {};

    timeframes.forEach(timeframe => {
      const days = this.timeframeToDays(timeframe);
      results[timeframe] = {
        timestamps: this.generateTimestamps(days),
        tvlUsd: Array(days).fill(1000000),
        apy: Array(days).fill(0.05),
        volumeUsd: Array(days).fill(100000),
        participants: Array(days).fill(50),
        priceData: { 'STX': Array(days).fill(1.0) },
        feesUsd: Array(days).fill(300),
        riskScore: Array(days).fill(50),
      };
    });

    return results;
  }

  // Real-time update methods
  async getRealtimeUpdate(opportunity: Opportunity): Promise<Partial<EnhancedChartData>> {
    if (!this.config.enableRealtimeUpdates) {
      return {};
    }

    try {
      // Get latest data point
      const [latestEnhancedData, latestRiskData] = await Promise.all([
        this.enhancedDataService.getEnhancedStabilityData(opportunity),
        this.getRiskData(opportunity, 1)
      ]);

      return {
        timestamps: [new Date().toISOString()],
        tvlUsd: [latestEnhancedData.currentTvl || opportunity.tvlUsd],
        apy: [this.aprToApy(latestEnhancedData.currentApr || opportunity.apr)],
        riskScore: [latestRiskData[0]],
      };
    } catch (error) {
      console.warn('Failed to get realtime update:', error);
      return {};
    }
  }

  // Data export utilities
  exportToCsv(chartData: EnhancedChartData, filename?: string): string {
    const headers = [
      'timestamp',
      'tvl_usd',
      'apy',
      'volume_usd',
      'participants',
      ...Object.keys(chartData.priceData).map(token => `price_${token}`),
      'fees_usd',
      'risk_score'
    ];

    const rows = chartData.timestamps.map((timestamp, index) => [
      timestamp,
      chartData.tvlUsd[index],
      chartData.apy[index],
      chartData.volumeUsd[index],
      chartData.participants[index],
      ...Object.keys(chartData.priceData).map(token => chartData.priceData[token][index]),
      chartData.feesUsd[index],
      chartData.riskScore[index]
    ]);

    return [headers, ...rows].map(row => row.join(',')).join('\n');
  }

  exportToJson(chartData: EnhancedChartData): string {
    return JSON.stringify(chartData, null, 2);
  }

  // Cache management
  clearCache(): void {
    this.cache.clear();
  }

  getCacheStats(): { entries: number; keys: string[]; memoryUsage: string } {
    const keys = Array.from(this.cache.keys());
    const estimatedSize = new Blob([JSON.stringify([...this.cache.values()])]).size;

    return {
      entries: this.cache.size,
      keys,
      memoryUsage: `${(estimatedSize / 1024).toFixed(2)} KB`,
    };
  }

  // Health check
  async healthCheck(): Promise<boolean> {
    try {
      // Test with a simple opportunity
      const testOpportunity: Opportunity = {
        id: 'test',
        name: 'Test Opportunity',
        tvlUsd: 1000000,
        apr: 0.05,
        apy: 0.051,
        chain: 'stacks',
        protocol: 'test',
        tokens: ['STX'],
        stablecoin: false,
        risk: 50,
        poolId: 'test-pool',
      };

      const chartData = await this.getPoolChartData(testOpportunity, ['7D']);
      return chartData['7D'].timestamps.length > 0;
    } catch (error) {
      console.warn('Chart data provider health check failed:', error);
      return false;
    }
  }
}